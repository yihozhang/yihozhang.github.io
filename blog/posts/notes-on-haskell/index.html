<b>Notice: I haven't learned catagory theory before, and most of this is based on my experience in learning haskell. </b>

<h3>Basics</h3>

<p>A <i>catagory</i> is a (bogus) set of semigroups, and elements in a catagory is called an object of the catagory. In haskell, we can think every type as an object, and the set of all types as the catagory. A functor can be thought as a mapping between catagories. Since we only have one catagory (the type system), all functors are endofunctors, functors mapping catagory to itself</p>

<p>Typeclass is like interface in object oriented programming. If some types or type constructor declare itself satiefies a typeclass, then it can be manipulated on the operation defined by the typeclass. Functor, Applicative, Monad are all typeclass in Haskell, i.e., we can say some types satiefy Functor, Applicative, and/or Monad.</p>

<p>And some reminders for Haskell</p>

<pre>-- A line starting with two dashs means a comment, which has no effect on the program

-- id is the identity function. And this is a function 
-- application, because we don't use paranthesis for
-- function, unlike what we do in mathematics. This
-- produces 1.
id 1

-- This declares a function f, which takes a parameter x
-- and produce the addition of x applied identity function 
-- twice, i.e., f x = x * 2.
f x = (id x) + (id x)

-- this is the fibonacci function. In declaring a function, 
-- when we write a constant after the function, we mean
-- pattern matching, which means if the parameter applied
-- satiefy the pattern (or in this case constant), then we
-- produce the result as the expression follows.
f 0 = 1
f 1 = 1
f x = (f (x - 1)) + (f (x - 2))
</pre>


<h3>Functor</h3>

<h4>Definition</h4>

<p>If there is a mapping (or type constructor in fact) $f$ from the catagory to itself such that every mapping in the catagory (between groups) before $f$ can has a corresponding mapping after $f$, then the mapping satisfies Functor. Symbolically, every mapping $a\mapsto b$ has a corresponding mapping $f(a)\mapsto f(b)$, then we say $f$ satisfies Functor (in Haskell) and we call the manipulation that turns a mapping into another mapping <tt>fmap</tt>, which however is exact the analogical definition of functor in catagory theory (instead of $f$). </p> The definition of Functor in Haskell:

<pre>class Functor (f :: * -> *) where
    fmap :: (a -> b) -> f a -> f b</pre>

<p>Also, Functors should obey two laws</p>

<ul>
    <li>Identity Element: <tt>fmap id = id</tt></li>
    <li>Distributivity: <tt>fmap (f . g) = (fmap f) . (fmap g)</tt></li>
</ul>

<h4>Examples</h4>

<p>We then see a few examples.</p>

<h5>Maybe</h5>

<p><tt>Maybe</tt> is a type constructor that takes in a type <tt>a</tt> and produces another type <tt>b</tt>. The element of <tt>b</tt> is either <tt>Nothing</tt> or <tt>Just v</tt>, where <tt>v</tt> is an element in <tt>a</tt>. We claim <tt>Maybe</tt> satiefies Functor by giving <tt>fmap</tt> as:</p>

<pre>-- the type of fmap
fmap :: (a -> b) -> (Maybe a) -> (Maybe b) 
-- the case of Nothing
fmap f Nothing = Nothing
the case of Maybe a
fmap f (Just a) = Just (f a)</pre>

<h5>Either</h5>

<p>Also, <tt>Either a b</tt> has elements either as <tt>Left v</tt> where <tt>v</tt> in <tt>a</tt> or <tt>Right v</tt> where <tt>v</tt> in <tt>b</tt>. Then <tt>Either a</tt> satiefy Functor, since Functors, in order to produce a type, should take one concrete type instead of two. <tt>Either a</tt> is a type constructor that takes a <tt>b</tt> and produce a concrete type <tt>Either a b</tt>. We call this as partial application of a function, or <i>currying</i>. We can give the <tt>fmap</tt> for <tt>Either a</tt>:</p>

<pre>fmap :: (a -> b) -> (Either a b) -> (Either a c)
fmap f (Left a) = Left a
fmap f (Right b) = Right (f b)</pre>

<p>It's a little weird that for <tt>Right b</tt>, <tt>fmap</tt> do nothing, but it makes senses since <tt>Either</tt> is likely to be used for restoring error message for <tt>b</tt>. If we store error message as <tt>Left a</tt>, then we don't need to do any manipulation on it.</p>

<ht>-></ht>

<p>A more weird example is <tt>-></tt>. We have seen <tt>-></tt> before, in the declation of a function type such as <tt>a -> b</tt>. This implies a function that takes <tt>a</tt> and produces <tt>b</tt>. But if we consider <tt>-></tt>, like <tt>+</tt>, as a type constructor, which takes two types on its left and right and then produce a function, we will find <tt>c -></tt>, the partial application of <tt>-></tt>, satiefy Functor (and this is exactly what Haskell do!):

<pre>fmap :: (a -> b) -> (c -> a) -> (c -> b)
fmap f g = \x -> f (g x)</pre>

<p>If you are unfamiliar of the notation <tt>\x -> f (g x)</tt>, it means a lambda function, which takes a parameter <tt>x</tt> and produce the expression after (<tt>f (g x)</tt>). <tt>f (g x)</tt> means to apply $x$ of type $c$ to $g:c\mapsto a$ and produce result of type $a$, and then applies $f:a\mapsto b$ to the result, which is of type $b$, therefore, the whole process is of type $c\mapsto b$. And we also find it's exact function composition! Therefore, in Haskell we can write <tt>fmap</tt> as <tt>fmap = .</tt>, where <tt>.</tt> is the annotation for type composition (since it's like its mathematical counterpart $\circ$)</p>

<h4>Exercise</h4>

<h5>Exercise 1</h5>

<p>We now build a list type:</p>

<pre>data MyList a = Empty | Cons a (MyList a)</pre>

<p>This means <tt>MyList a</tt> is either <tt>Empty</tt>, or in the form of <tt>Cons x y</tt>, where $x\in a$ and $y\in \text{MyList a}$. So a list like $[1, 2, 3]$ will be like <tt>Cons 1 (Cons 2 (Cons 3 Empty))</tt>. Prove that the type constructor <tt>MyList</tt> can satisfy Functor.</p>

<h5>Exercise 2</h5>

<p>Give a Functor-like type that however does not hold distributivity.</p>

<h3>Applicative Functor</h3>

<h4>Motivation</h4>

<p>How do we represent the order of computation in a functional language? To be more specific, how do we specify the order of computation of the following expression?</p>

<pre>result = (nextInt + nextInt * nextInt</pre>

<p>Even though we know the priority of <tt>*</tt> is over <tt>+</tt>, we still don't know which <tt>nextInt</tt> is calculated first. Thinking for a while, I would write the following code:</p>

<pre>result =
    let a = nextInt in
        let b = nextInt in
            let c = nextInt in
                (a + b) + c</pre>

<p>By removing the language sugar of let-in notationa, this is equivalent to</p>

<pre>result = (\a ->
    ((\b -> 
        ((\c -> (a + b) * c)
         nextInt))
    nextInt)) nextInt</pre>

<p>But this is not a good idea to expose <tt>nextInt</tt> in an unprotected environment, since then for every argument we should have a function-call wrap. Also, this leaves the guarantee to the clients. To be robust, we can use a type constructor to wrap the value, i.e., <tt>IO a</tt>, for which <tt>a</tt> can be taken out of. Now we find if <tt>x :: IO a</tt> and <tt>y :: IO a</tt>, then <tt>x</tt> and <tt>y</tt> can occur in the same expression, as long as we define some ordered operation to take out the value in the wrapper <tt>IO a</tt>.</p>

<p>Some hints come from functor, that we can construct a function <tt>f a -> f b -> f c</tt> from operations of <tt>a -> b -> c</tt>. More specificially, we take <tt>a</tt> out of <tt>f a</tt>, <tt>b</tt> out of <tt>f b</tt>, and calculate <tt>a -> b -> c</tt> to wrap it as <tt>f c</tt>. In this process, because of currying, the first parameter should combine with <tt>f a -> f b -> f c</tt> to obtain <tt>f b -> f c</tt>, the second parameter combine with <tt>f b -> f c</tt> to get <tt>f c</tt>.</p>

<p>Let's think back of the definition of <tt>fmap :: (a -> b) -> f a -> f b</tt>: What if we throw in the first parameter of some type <tt>a -> b -> c</tt>. Well, then the type of <tt>fmap</tt> becomes <tt>(a -> (b -> c)) -> f a -> f (b -> c)</tt>, for which our goals failed. To achieve our goal, we need a new operation: <tt>f (b -> c) -> f b -> f c</tt>. Denote it as an infix operator <tt><*></tt>, whence <tt>( g :: f (a -> b -> c) <*> a :: f a ) :: f (b -> c)</tt>, which takes the value of <tt>a</tt> out of the wrapper, and <tt>( g :: f (b -> c) <*> b :: f b ) :: f c</tt>, which take the value of <tt>b</tt> out of the wrapper. What happens here is the order that values are taken out of the wrapper is determined, and this can be extend to functions that have more arguments! Therefore, with this, we can calculate unwrap all the wrapped types in order for calculation. More formally, we define</p>

<pre>class Functor f => Applicative (f :: * -> *) where
    pure :: a -> f a
    (<*>) :: f (a -> b) -> f a -> f b</pre>

<p>and for conveinence we define</p>

<pre><$> = fmap</pre>

<p>Then <tt>liftA2 :: (a -> b -> c) -> f a -> f b -> f c</tt> can be defined as</p>

<pre>liftA2 = \f x y -> f <$> x <*> y</pre>

<h4>Examples</h4>

<h5>Maybe</h5>

<pre>pure a = Just a
(Just f) <*> (Just a) = Just (f a)
Nothing <*> _ = Nothing
_ <*> Nothing = Nothing</pre>

The same should work for <tt>Either a</tt>.

<h4>List</h4>

An interesting example is <tt>[a]</tt>. We define

<pre>pure a = [a]
fs <*> xs = [f x | f <- fs, x <- xs]
</pre>

Then <tt>(*) <$> [1,2] <*> [1,2]</tt> is equal to <tt>[1,2,2,4]</tt>, and <tt>[(+),(*)] <*> [1,2,3] <*> [4,5,6]</tt> is equal to <tt>[5,6,7,6,7,8,7,8,9,4,5,6,8,10,12,12,15,18]</tt>.



