<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Yihong Zhang" />
  <title>A tutorial on the imaginary Gogi language</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
      }
    pre.numberSource { margin-left: 3em;  padding-left: 4px; }
    div.sourceCode
      { color: #cccccc; background-color: #303030; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ffcfaf; } /* Alert */
    code span.an { color: #7f9f7f; font-weight: bold; } /* Annotation */
    code span.at { } /* Attribute */
    code span.bn { color: #dca3a3; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #f0dfaf; } /* ControlFlow */
    code span.ch { color: #dca3a3; } /* Char */
    code span.cn { color: #dca3a3; font-weight: bold; } /* Constant */
    code span.co { color: #7f9f7f; } /* Comment */
    code span.cv { color: #7f9f7f; font-weight: bold; } /* CommentVar */
    code span.do { color: #7f9f7f; } /* Documentation */
    code span.dt { color: #dfdfbf; } /* DataType */
    code span.dv { color: #dcdccc; } /* DecVal */
    code span.er { color: #c3bf9f; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #c0bed1; } /* Float */
    code span.fu { color: #efef8f; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #7f9f7f; font-weight: bold; } /* Information */
    code span.kw { color: #f0dfaf; } /* Keyword */
    code span.op { color: #f0efd0; } /* Operator */
    code span.ot { color: #efef8f; } /* Other */
    code span.pp { color: #ffcfaf; font-weight: bold; } /* Preprocessor */
    code span.sc { color: #dca3a3; } /* SpecialChar */
    code span.ss { color: #cc9393; } /* SpecialString */
    code span.st { color: #cc9393; } /* String */
    code span.va { } /* Variable */
    code span.vs { color: #cc9393; } /* VerbatimString */
    code span.wa { color: #7f9f7f; font-weight: bold; } /* Warning */
  </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">A tutorial on the imaginary Gogi language</h1>
<p class="author">Yihong Zhang</p>
</header>
<p>Welcome to the tutorial on Gogi (short for
eg<strong>g</strong>l<strong>ogi</strong>sh), a made-up language that
attempts to generalize both <a
href="https://en.wikipedia.org/wiki/Datalog">Datalog</a> and <a
href="https://egraphs-good.github.io">egg</a>. This blog stems from a <a
href="https://github.com/nikomatsakis/plmw-2022">trick</a> I learned
from Nicholas Matsakis at PLMW 2022: To write a tutorial for a
non-existing language. By doing this, I can get a sense of what I want
from this new language as well as early feedbacks from others.</p>
<p>Why Gogi? The motivation behind Gogi is to find a good model for
relational e-graphs that can take full advantage of (1) performance of
relational e-matching and (2) expressiveness of Datalog, while (3) being
compatiable with egg as well as (4) efficient. This is the first
approach I described at the beginning of the previous <a
href="blog/ematch-trick.html">post</a>. I’m actually more excited about
this approach, because I believe this is <em>the right way</em> in long
term.</p>
<p>Gogi is Datalog, so it supports various reasoning expressible in
Datalog. A rule has the form
<code>head1, ..., headn :- body1, ..., bodyn</code>. For example, below
is a valid egg# program:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>rel link(string<span class="kw">,</span> string) from <span class="ot">&quot;./</span><span class="er">link</span><span class="ot">.</span><span class="er">csv</span><span class="ot">&quot;</span><span class="kw">.</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>rel tc(string<span class="kw">,</span> string)<span class="kw">.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>tc(a<span class="kw">,</span> b) <span class="kw">:-</span> link(a<span class="kw">,</span> b)<span class="kw">.</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>tc(a<span class="kw">,</span> b) <span class="kw">:-</span> link(a<span class="kw">,</span> c)<span class="kw">,</span> tc(c<span class="kw">,</span> b)<span class="kw">.</span></span></code></pre></div>
<p>However, Datalog by itself is not that interesting. So for the first
part of the post, I will instead focus on the extensions that make Gogi
interesting. Next, I’ll give some examples and show why Gogi generalizes
egg I will also try to develop the operational and model semantics of
Gogi. <!-- Finally, I'll discuss some thoughts on Gogi. --></p>
<h1 id="introduction-to-gogi">Introduction to Gogi</h1>
<h2 id="ext-1-user-defined-sorts-and-lattices">Ext 1: User-defined sorts
and lattices</h2>
<p>In Gogi, every value is either a (semi)lattice value or a sort value.
Lattices in Gogi are algebraic structures with a binary join operator
(<span class="math inline">\(\lor\)</span>) that is associative,
commutative, and idempotent and a default top <span
class="math inline">\(\top\)</span> where <span
class="math inline">\(\top\lor e=\top\)</span> for all <span
class="math inline">\(e\)</span>. For example, standard types like
<code>string</code>, <code>i64</code>, and <code>u64</code> in Gogi are
in fact trivial lattices with <span class="math inline">\(s_1\lor s_2
=\top\)</span> for all <span class="math inline">\(s_1\neq s_2\)</span>.
In Gogi, <span class="math inline">\(\top\)</span> means unresolvable
errors. Users can define their own lattices by providing a definition
for lattice join.</p>
<p>Similarly, users can define sorts. Unlike lattices, sorts are
uninterpreted. As a result, sort values can only be created implicitly
via functional dependency. We will go back to this point later.</p>
<h2 id="ext-2-relations-and-functional-dependencies">Ext 2: Relations
and Functional Dependencies</h2>
<h3 id="declaring-a-relation-with-functional-dependency">Declaring a
relation with functional dependency</h3>
<p>Relations can be declared using the <code>rel</code> keyword.
Moreover, it is possible to specify a functional dependency between
columns in Gogi. For example,</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>sort expr<span class="kw">.</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>rel num(i64) <span class="kw">-&gt;</span> expr<span class="kw">.</span></span></code></pre></div>
<p>declares a sort called <code>expr</code> and a <code>num</code>
relation with two columns <code>(i64, expr)</code>. In the
<code>num</code> relation, each <code>i64</code> uniquely determines the
remaining column (i.e., <code>num(x, e1)</code> and
<code>num(x, e2)</code> implies <code>e1 = e2</code>). The
<code>num</code> relation can be read as a function from
<code>i64</code> to values in <code>expr</code>. Similar declarations
are ubiquitous in Gogi to represent sort constructors.</p>
<p>As another example,</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>rel add(expr<span class="kw">,</span> expr) <span class="kw">-&gt;</span> expr<span class="kw">.</span></span></code></pre></div>
<p>declares a relation with three columns, and the first two columns
together uniquely determines the third column. This represents a
constructor that takes two <code>expr</code>s.</p>
<p>Users can introduce new sort values with functional dependencies.
Example:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>num(<span class="dv">1</span><span class="kw">,</span> c)<span class="kw">.</span> <span class="co">% equivalently, num(1, _).</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>num(<span class="dv">2</span><span class="kw">,</span> d)<span class="kw">.</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>add(c<span class="kw">,</span> d<span class="kw">,</span> e) <span class="kw">:-</span> num(<span class="dv">1</span><span class="kw">,</span> c)<span class="kw">,</span> num(<span class="dv">2</span><span class="kw">,</span> d)<span class="kw">.</span></span></code></pre></div>
<p>This program is interesting and its semantics deviates from the one
in standard Datalog. In standard Datalog, this program will not compile
because variable <code>c</code> in the first rule, <code>d</code> in the
second rule, and <code>e</code> in the third rule are not bound.
However, this is a valid program in Gogi. Thanks to functional
dependency, variables associated to head atoms do not necessarily have
to be bound in the bodies. The above Gogi program is roughly equivalent
to the following Datalog program:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>num(<span class="dv">1</span><span class="kw">,</span> c) <span class="kw">:-</span> <span class="kw">!</span>num(<span class="dv">1</span><span class="kw">,</span> <span class="dt">_</span>)<span class="kw">,</span> c <span class="kw">=</span> new_expr()<span class="kw">.</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>num(<span class="dv">2</span><span class="kw">,</span> d) <span class="kw">:-</span> <span class="kw">!</span>num(<span class="dv">2</span><span class="kw">,</span> <span class="dt">_</span>)<span class="kw">,</span> d <span class="kw">=</span> new_expr()<span class="kw">.</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>add(c<span class="kw">,</span> d<span class="kw">,</span> e) <span class="kw">:-</span> num(<span class="dv">1</span><span class="kw">,</span> c)<span class="kw">,</span> num(<span class="dv">2</span><span class="kw">,</span> d)<span class="kw">,</span> <span class="kw">!</span>add(c<span class="kw">,</span> d<span class="kw">,</span> <span class="dt">_</span>)<span class="kw">,</span> e <span class="kw">=</span> new_expr()</span></code></pre></div>
<p>Negated atoms like <code>!num(1, _)</code> is necessary here because
otherwise it will inserts more than one atoms matching
<code>num(1, _)</code>, which violates the functional dependency
associated to the relation.</p>
<p>The example Gogi program can also be written into one single rule
with multiple heads:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>add(c<span class="kw">,</span> d<span class="kw">,</span> e)<span class="kw">,</span> num(<span class="dv">1</span><span class="kw">,</span> c)<span class="kw">,</span> num(<span class="dv">2</span><span class="kw">,</span> d)<span class="kw">.</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co">% roughly equivalent to </span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">% add(c, d, e), num(1, c), num(2, d) :- !num(1, _), !num(2, _), </span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co">%                                       c = new_expr(), </span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co">%                                       d = new_expr(),</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co">%                                       !add(c, d, _),</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co">%                                       e = new_expr().</span></span></code></pre></div>
<h2 id="the-bracket-syntax">The bracket syntax</h2>
<p>Gogi also supports the bracket syntax, so it can be further
simplified to:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>add[num[<span class="dv">1</span>], num[<span class="dv">2</span>]]<span class="kw">.</span></span></code></pre></div>
<p>The bracket syntax will implicitly fill the omitted column(s) with
newly generated variable(s). If the atom is in nested inside another
term, the nested atom will be lifted to the top-level, and the generated
variable(s) will take the original position of the atom. Another silly
example of the bracket syntax:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>ans(x) <span class="kw">:-</span> <span class="al">xor</span>[<span class="al">xor</span>[x]]<span class="kw">.</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co">% expands to</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co">% ans(x) :- xor[y, z], xor(x, y, z)</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co">% which expands to</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co">% ans(x) :- xor(y, z, _), xor(x, y, z)</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co">% this rule can be thought as</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="co">%   for any expr x, y where `y xor (x xor y)`</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co">%   is present in the database, collect x as the result.</span></span></code></pre></div>
<p>Finally, in equational reasoning a la egg, it is common to write
rules like “for every <code>(a + b) + c</code>, populate
<code>a + (b + c)</code> on the right and make them equivalent”. This
rule will look like the following:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>add(a<span class="kw">,</span> add[b, c]<span class="kw">,</span> id) <span class="kw">:-</span> add(add[a, b]<span class="kw">,</span> c<span class="kw">,</span> id)<span class="kw">.</span></span></code></pre></div>
<p>Gogi further has a syntactic sugar for these equational rules:
<code>head := body if body1 ... bodyn</code> where both
<code>head</code> and <code>body</code> should use the bracket syntax
and omit the same number of columns. The if clause can be omitted. Gogi
will expand this syntactic sugar by unfolding the top-level bracket in
<code>head</code> and <code>body</code> with the same variable(s):</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>add[b, a] := add[a, b]<span class="kw">.</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co">% unfolds to add(b, a, id) :- add(a, b, id).</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>add[a, add[b, c]] := add[add[a, b], c]<span class="kw">.</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co">% unfolds to add(a, add[b, c], id) :- add(add[a, b], c, id).</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>num[<span class="dv">1</span>] := <span class="fu">div</span>[a, a] if num(x<span class="kw">,</span> a)<span class="kw">,</span> x <span class="kw">!=</span> <span class="dv">0</span><span class="kw">.</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="co">% unfolds to num(1, id) :- div(a, a, id), num(x, a), x != 0.</span></span></code></pre></div>
<p>Note the equational rules may introduce functional dependency
violation; for instance, last rule may cause multiple tuples to match
<code>num(1, _)</code>, yet the first column should uniquely determines
the tuple. We will introduce how we resolve this kind of violations in
the section on <a href="#ext-3-functional-dependency-repair">Functional
Dependency Repair</a>.</p>
<h3 id="relations-with-lattices">Relations with lattices</h3>
<p>The example relations we see so far mostly center around sort values.
However, it is also possible and indeed very useful to define relations
with lattices:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>rel hi(expr) <span class="kw">-&gt;</span> lmax(<span class="fu">-</span><span class="dv">2147483648</span>)<span class="kw">.</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>rel lo(expr) <span class="kw">-&gt;</span> lmin(<span class="dv">2147482647</span>)<span class="kw">.</span></span></code></pre></div>
<p>To define a lattice column, a default value need to be provided in
the relation definition. The default value is not a lattice bottom: the
bottom means do not exist. Meanwhile, the lattice top means there are
conflicts. It is also possible for default value to refer to the
determinant columns:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>rel add1(i<span class="fu">:</span> i64) <span class="kw">-&gt;</span> i64(i <span class="fu">+</span> <span class="dv">1</span>)<span class="kw">.</span></span></code></pre></div>
<p>The column initialization syntax should be reminiscent of C++’s <a
href="https://en.cppreference.com/w/cpp/language/constructor">member
initializer lists</a>.</p>
<p>In the above example, <code>lo</code> and <code>hi</code> together
define a range analysis for the <code>expr</code> sort. This in facts
generalizes the e-class analyses in egg. Here are some rules for
<code>hi</code> and <code>lo</code> (stolen from Zach):</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>hi(x<span class="kw">,</span> n<span class="al">.</span>into()) <span class="kw">:-</span> num(n<span class="kw">,</span> x)<span class="kw">.</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>lo(x<span class="kw">,</span> n<span class="al">.</span>into()) <span class="kw">:-</span> num(n<span class="kw">,</span> x)<span class="kw">.</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>lo(nx<span class="kw">,</span> n<span class="al">.</span>negated()) <span class="kw">:-</span> hi(x<span class="kw">,</span> n)<span class="kw">,</span> neg(x<span class="kw">,</span> nx)<span class="kw">.</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>hi(nx<span class="kw">,</span> n<span class="al">.</span>negated()) <span class="kw">:-</span> lo(x<span class="kw">,</span> n)<span class="kw">,</span> neg(x<span class="kw">,</span> nx)<span class="kw">.</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>lo(absx<span class="kw">,</span> <span class="dv">0</span>) <span class="kw">:-</span> abs(x<span class="kw">,</span> absx)<span class="kw">.</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>lo[absx] := lo[x] if abs(x<span class="kw">,</span> absx)<span class="kw">,</span> lo[x] <span class="dt">&gt;=</span> <span class="dv">0</span><span class="kw">.</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>hi[absx] := hi[x] if abs(x<span class="kw">,</span> absx)<span class="kw">,</span> lo[x] <span class="dt">&gt;=</span> <span class="dv">0</span><span class="kw">.</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>lo(xy<span class="kw">,</span> lox <span class="fu">+</span> loy) <span class="kw">:-</span> lo(x<span class="kw">,</span> lox)<span class="kw">,</span> hi(y<span class="kw">,</span> loy)<span class="kw">,</span> add(x<span class="kw">,</span> y<span class="kw">,</span> xy)<span class="kw">.</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="co">% can be further simplified to</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="co">%   lo[xy] := lo[x] + lo[y] if add(x, y, xy)</span></span></code></pre></div>
<p>Note here instead of
<code>lo(neg[x], n.negated()) :- hi(x, n).</code>, we put the
<code>neg</code> atom to the right-hand side and write
<code>lo(nx, n.negated()) :- hi(x, n), neg(x, nx).</code> There are some
nuanced differences between the two rules. This rule, besides doing what
the second rule does, always populates a <code>neg</code> tuple for each
<code>hi</code> tuple even when it does not exist, so the first rule can
be viewed as an “annotation-only” version of the first rule, which is
usually what we want.</p>
<p>The last example shows e-class analyses in Gogi is composable (i.e.,
each analysis can freely refer to each other). This is one of the reason
why we believe Gogi generalizes e-class analyses. Moreover, they can
also interact with other non-lattice relations in a meaningful way: <a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a></p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>rel geq(expr<span class="kw">,</span> expr)<span class="kw">.</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="co">% ... some arithmetic rules ...</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="co">% need to convert to int because they are from different lattices</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>geq(a<span class="kw">,</span> b) <span class="kw">:-</span> lo[a]<span class="kw">.</span>to_int() <span class="dt">&lt;</span> hi<span class="er">[</span>b<span class="er">]</span><span class="kw">.</span>to_int()<span class="kw">.</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="co">% </span><span class="al">TODO</span><span class="co">: geq is quadratic in size. </span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="co">% Gogi should support inlined relations</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="co">% to avoid materialize relations like geq</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="co">% ... other user-defined knowledge about geq</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="co">% x and abs[x] are equivalent when x &gt; 0</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>x := abs[x] if geq(x<span class="kw">,</span> num[<span class="dv">0</span>])</span></code></pre></div>
<p>Diverging a little bit, it is even possible to write the above rules
without using analyses / relations with lattices:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>sort bool<span class="kw">.</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>rel <span class="kw">true</span>() <span class="kw">-&gt;</span> bool<span class="kw">.</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>rel <span class="kw">false</span>() <span class="kw">-&gt;</span> bool<span class="kw">.</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>rel geq(expr<span class="kw">,</span> expr) <span class="kw">-&gt;</span> bool<span class="kw">.</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="co">% for each abs[x] exists, populate geq[x, 0],</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="co">% in the hope that later </span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="co">% it will be &quot;in the same e-class&quot; as true[].</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>geq[x, <span class="dv">0</span>] <span class="kw">:-</span> abs[x]</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>geq[numx, <span class="dv">0</span>] := <span class="kw">true</span>[] if num(x<span class="kw">,</span> numx)<span class="kw">,</span> x <span class="dt">&gt;</span> <span class="dv">0</span><span class="kw">.</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>geq[xx, <span class="dv">0</span>] := <span class="kw">true</span>[] if mul(x<span class="kw">,</span> x<span class="kw">,</span> xx)<span class="kw">.</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a><span class="co">% if x &gt; 0 and y &gt; 0 are both equivalent to true,</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a><span class="co">% then x + y &gt; 0 is also equivalent to true.</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>geq[xy, <span class="dv">0</span>] := <span class="kw">true</span>[] </span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>           if add(x<span class="kw">,</span> y<span class="kw">,</span> xy)<span class="kw">,</span> </span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>              geq(x<span class="kw">,</span> <span class="dv">0</span><span class="kw">,</span> <span class="kw">true</span>[])<span class="kw">,</span> </span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>              geq(y<span class="kw">,</span> <span class="dv">0</span><span class="kw">,</span> <span class="kw">true</span>[])</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>geq[xxyy, <span class="dv">0</span>] := <span class="kw">true</span>[] if add(mul[x, x]<span class="kw">,</span> mul[y, y]<span class="kw">,</span> xxyy)<span class="kw">.</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a><span class="co">% ... other reasoning rules...</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a><span class="co">% if x&gt;0 is equivalent to true,</span></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a><span class="co">% every abs[x] in the database should be equivalent to x </span></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>x := abs[x] if geq(x<span class="kw">,</span> <span class="dv">0</span><span class="kw">,</span> <span class="kw">true</span>[])</span></code></pre></div>
<p>The above program can be seen as implementing a small theorem prover
in Gogi. Whenever it sees abs[x], a query about <code>x &gt;= 0</code>
will be issued to the database. If later <code>x &gt;= 0</code> is
proven to be equivalent to true, a distinguished sort value,
<code>abs[x]</code> will be put in the same e-class as
<code>x</code>.</p>
<p>All these rewrite will be very hard to express in egg.</p>
<h2 id="ext-3-functional-dependency-repair">Ext 3: Functional Dependency
Repair</h2>
<section class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p> The last rule in this example has a
single variable on the left-hand side, but the above mentioned syntactic
expansion for <code>:=</code> does not apply to this case. The rule is
indeed equivalent to
<code>abs(x, x) :- abs[x] if geq(x, num[0])</code>.<a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
